import cv2
import numpy as np
import matplotlib.pyplot as plt
import json
import os
from glob import glob

image_path = r"D:\Example Ingreso AA\Libro AA\4_a.jpg"

# 4 FUNCIONES DE PREPROCESAMIENTO, ALIGERAN LA IMAGEN, RECUADRAN Y RECORTAN LA PAGINA DETECTANDO EL RECTANGULO MAYOR.

def preprocess_page(image_path, max_width=1200, threshold_value=140):
    """Procesamiento mejorado con:
    - Conservación de detalles finos
    - Umbralado ajustable
    - Texto BLANCO sobre fondo NEGRO (estándar OCR)
    """
    # 1. Carga y redimensionamiento
    img = cv2.imread(image_path)
    if img is None:
        raise ValueError("Error al cargar la imagen")
    
    # Reducción proporcional
    h, w = img.shape[:2]
    if w > max_width:
        scale = max_width / w
        img = cv2.resize(img, None, fx=scale, fy=scale, interpolation=cv2.INTER_CUBIC)
    
    # 2. Preprocesamiento básico
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (3,3), 0)
    
    # 3. Mejoramiento de contraste
    clahe = cv2.createCLAHE(clipLimit=4.0, tileGridSize=(16,16))
    enhanced = clahe.apply(blurred)
    
    # 4. Umbralado final (TEXTO BLANCO sobre fondo NEGRO)
    _, final = cv2.threshold(enhanced, threshold_value, 255, cv2.THRESH_BINARY)  # Cambiado a THRESH_BINARY
    
    return final

def preprocess_page_rectangle(tresh):
    # 1. Umbralizar para asegurar imagen binaria
    _, binary = cv2.threshold(tresh, 127, 255, cv2.THRESH_BINARY)
    
    # 2. Encontrar contornos
    contours, _ = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    
    if not contours:
        raise ValueError("No se encontraron contornos")
    
    # 3. Ordenar contornos por área
    contours = sorted(contours, key=cv2.contourArea, reverse=True)
    largest_contour = contours[0]
    
    # 4. Aproximar a rectángulo
    perimeter = cv2.arcLength(largest_contour, True)
    epsilon = 0.01 * perimeter
    approx = cv2.approxPolyDP(largest_contour, epsilon, True)
    
    if len(approx) == 4:
        rectangular_contour = approx
    else:
        # Forzar aproximación rectangular
        rect = cv2.minAreaRect(largest_contour)
        rectangular_contour = cv2.boxPoints(rect)
        rectangular_contour = np.int0(rectangular_contour)
    
    # 5. Crear imagen de visualización (CONVERTIR A COLOR)
    img_with_contours = cv2.cvtColor(tresh, cv2.COLOR_GRAY2BGR)  # Conversión crucial
    
    # Dibujar TODOS los contornos en verde claro
    cv2.drawContours(img_with_contours, contours, -1, (0, 255, 0), 1)
    
    # Dibujar el contorno más grande en azul
    cv2.drawContours(img_with_contours, [largest_contour], -1, (255, 0, 0), 2)
    
    # Dibujar el rectángulo aproximado en rojo
    cv2.drawContours(img_with_contours, [rectangular_contour], -1, (0, 0, 255), 3)
    
    return img_with_contours, rectangular_contour  # Devuelve ambos para uso posterior

def order_points(pts):
    """
    Ordena los puntos del rectángulo en el orden:
    top-left, top-right, bottom-right, bottom-left
    """
    rect = np.zeros((4, 2), dtype=np.float32)
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]  # Top-left
    rect[2] = pts[np.argmax(s)]  # Bottom-right
    
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)]  # Top-right
    rect[3] = pts[np.argmax(diff)]  # Bottom-left
    
    return rect

def crop_rectangular_region(image, rectangular_contour, margin=-10):
    """
    Realiza un verdadero recorte rectangular del área del documento
    aplicando primero la corrección de perspectiva.
    
    :param image: Imagen original
    :param rectangular_contour: Contorno de 4 puntos del rectángulo
    :param margin: Margen adicional alrededor del documento (en píxeles)
    :return: Imagen recortada y enderezada
    """
    # 1. Ordenar los puntos del contorno
    rect_points = rectangular_contour.reshape(4, 2)
    ordered_points = order_points(rect_points)
    
    # 2. Calcular las dimensiones del documento
    width = int(max(
        np.linalg.norm(ordered_points[0] - ordered_points[1]),
        np.linalg.norm(ordered_points[2] - ordered_points[3])
    ))
    
    height = int(max(
        np.linalg.norm(ordered_points[1] - ordered_points[2]),
        np.linalg.norm(ordered_points[3] - ordered_points[0])
    ))
    
    # 3. Definir los puntos de destino (con margen)
    dst_points = np.array([
        [margin, margin],
        [width + margin - 1, margin],
        [width + margin - 1, height + margin - 1],
        [margin, height + margin - 1]
    ], dtype=np.float32)
    
    # 4. Calcular la matriz de transformación
    M = cv2.getPerspectiveTransform(ordered_points, dst_points)
    
    # 5. Aplicar la transformación
    warped = cv2.warpPerspective(image, M, 
                               (width + 2*margin, height + 2*margin))
    
    return warped

processed = preprocess_page(image_path, max_width=1800)  # IMAGEN LIVIANA

img, rectangle = preprocess_page_rectangle(processed)  # ENCUENTRA EL RECTÁNGULO

page = crop_rectangular_region(processed, rectangle, margin=-10) # RECORTA RECTAGULO EN IMAGEN, MARGEN NEGATIVO PARA QUEDARSE SOLO CON SECTOR PÁGINA, MODIFICABLE

# Visualización 
plt.figure(figsize=(16, 10), dpi=150)
plt.imshow(page, cmap='gray', vmin=0, vmax=255)
plt.axis('off')
plt.tight_layout()
plt.show()

# Guardado de alta calidad
cv2.imwrite("documento_procesado_hq.png", page, 
           [cv2.IMWRITE_PNG_COMPRESSION, 0])  # Máxima calidad

# UNA VEZ CON LA PÁGINA, EL OBJETIVO ES SEPARAR POR COLUMNAS. ESTAS SE DETECTAN CON HUGUES.LINES, SE FILTRAN LAS VÁLIDAS Y 
# LUEGO SE EXTIENDEN PARA CUBRIR LA PAGINA, SIN PERDER EL ANGULO DE INCLINACIÓN. LUEGO SE ORDENAN DE IZQ A DER, SE CORRIGE
# LA PERSPECTIVA, SE EXTRAEN Y GUARDAN.

def detect_columns(image, min_line_length=170, max_line_gap=10, angle_tolerance=3):
    """
    Detecta líneas verticales para identificar columnas usando Transformada de Hough.
    Devuelve las coordenadas x promedio de las líneas verticales ordenadas.

    Args:
        image: Imagen preprocesada (escala de grises)
        min_line_length: Longitud mínima de línea a detectar (en píxeles)
        max_line_gap: Máxima separación permitida entre segmentos de línea

    Returns:
        Lista ordenada de coordenadas x de líneas verticales detectadas
    """
    # Detección de bordes con parámetros optimizados para documentos
    edges = cv2.Canny(image, 50, 150, apertureSize=3)
    
    # Detección de líneas con HoughLinesP
    lines = cv2.HoughLinesP(
        edges,
        rho=1,
        theta=np.pi/180,
        threshold=100,
        minLineLength=min_line_length,
        maxLineGap=max_line_gap
    )    
    
    vertical_lines = []

    for line in lines:
        [[x1, y1, x2, y2]] = line
        angle = np.abs(np.arctan2(y2 - y1, x2 - x1) * 180 / np.pi)
        
        if 90 - angle_tolerance < angle < 90 + angle_tolerance:
            vertical_lines.append([[x1, y1, x2, y2]])  # Mantener estructura original

    return vertical_lines

def extend_lines_preserving_angle(lines, image):
    """
    Extiende líneas a todo el alto de la imagen conservando su ángulo exacto.
    
    Args:
        lines: Array de líneas en formato [[[x1, y1, x2, y2]]]
        image_height: Altura total de la imagen (por defecto 2400)
        
    Returns:
        Array de líneas extendidas (mismo formato) conservando el ángulo original
    """
    extended_lines = []
    
    for line in lines:
        [[x1, y1, x2, y2]] = line
        
        # Calcular pendiente (dy/dx) de la línea original
        dx = x2 - x1
        dy = y2 - y1
        
        # Evitar división por cero para líneas perfectamente verticales
        if dx == 0:
            extended_line = [[
                np.int32(x1),
                np.int32(0),
                np.int32(x1),
                np.int32(image.shape[0] - 1)
            ]]
        else:
            # Calcular pendiente (m) e intercepto (b) de la ecuación de la recta: y = m*x + b
            m = dy / dx
            b = y1 - m * x1
            
            # Calcular nuevos puntos que extiendan la línea a los bordes de la imagen
            # Punto superior (y=0)
            x_top = int((0 - b) / m) if m != 0 else x1
            # Punto inferior (y=image_height-1)
            x_bottom = int((image.shape[0]-1 - b) / m) if m != 0 else x1
            
            extended_line = [[
                np.int32(x_top),
                np.int32(0),
                np.int32(x_bottom),
                np.int32(image.shape[0] - 1)
            ]]
        
        extended_lines.append(extended_line)
    
    return np.array(extended_lines, dtype=np.int32)

def filter_close_lines_simple(extended_lines, min_distance=20):
    """
    Versión simplificada sin clustering, para casos con pocas líneas.
    """
    if len(extended_lines) == 0:
        return extended_lines
    
    lines_array = np.array(extended_lines).reshape(-1, 4)
    x_positions = (lines_array[:, 0] + lines_array[:, 2]) / 2
    sorted_indices = np.argsort(x_positions)
    
    filtered_indices = [sorted_indices[0]]
    for idx in sorted_indices[1:]:
        current_x = x_positions[idx]
        last_x = x_positions[filtered_indices[-1]]
        if np.abs(current_x - last_x) >= min_distance:
            filtered_indices.append(idx)
    
    return lines_array[filtered_indices].reshape(-1, 1, 4)

def sort_vertical_lines(extended_lines):
    """
    Ordena líneas verticales por su posición X más a la izquierda.
    
    Args:
        extended_lines: Lista de líneas en formato [[[x1, y1, x2, y2]]]
        
    Returns:
        Líneas ordenadas de izquierda a derecha según su posición mínima en X
    """
    # Convertir a array numpy si no lo es
    lines_array = np.array(extended_lines).reshape(-1, 4)
    
    # Calcular el valor X mínimo de cada línea (entre x1 y x2)
    min_x_values = np.minimum(lines_array[:, 0], lines_array[:, 2])
    
    # Obtener los índices ordenados
    sorted_indices = np.argsort(min_x_values)
    
    # Reordenar las líneas
    sorted_lines = lines_array[sorted_indices]
    
    # Reformatear al formato original [[[x1,y1,x2,y2]]]
    return sorted_lines.reshape(-1, 1, 4)

def correct_column_perspective(image, line1, line2):
    """
    Corrige la perspectiva entre dos líneas para crear una columna rectangular.
    
    Args:
        image: Imagen original
        line1: Primera línea en formato [x1,y1,x2,y2]
        line2: Segunda línea en formato [x1,y1,x2,y2]
        
    Returns:
        Imagen de la columna corregida
    """
    # Obtener coordenadas de las líneas
    l1x1, l1y1, l1x2, l1y2 = line1
    l2x1, l2y1, l2x2, l2y2 = line2
    
    # Definir puntos de origen (en el orden: top-left, top-right, bottom-right, bottom-left)
    src_points = np.float32([
        [l1x1, l1y1],  # Punto superior izquierdo (línea izquierda)
        [l2x1, l2y1],  # Punto superior derecho (línea derecha)
        [l2x2, l2y2],  # Punto inferior derecho
        [l1x2, l1y2]   # Punto inferior izquierdo
    ])
    
    # Calcular el ancho de la columna (usando el máximo entre superior e inferior)
    width_top = np.linalg.norm(src_points[1] - src_points[0])
    width_bottom = np.linalg.norm(src_points[2] - src_points[3])
    max_width = max(int(width_top), int(width_bottom))
    
    # Calcular la altura de la columna (usando el promedio de las alturas de las líneas)
    height_left = np.linalg.norm(src_points[3] - src_points[0])
    height_right = np.linalg.norm(src_points[2] - src_points[1])
    avg_height = int((height_left + height_right) / 2)
    
    # Puntos de destino (rectángulo perfecto)
    dst_points = np.float32([
        [0, 0],
        [max_width - 1, 0],
        [max_width - 1, avg_height - 1],
        [0, avg_height - 1]
    ])
    
    # Calcular matriz de transformación de perspectiva
    M = cv2.getPerspectiveTransform(src_points, dst_points)
    
    # Aplicar la transformación
    column = cv2.warpPerspective(image, M, (max_width, avg_height))
    
    return column

def extract_columns_with_perspective(image, extended_lines, padding=10):
    """
    Extrae columnas aplicando corrección de perspectiva entre pares de líneas.
    
    Args:
        image: Imagen original
        extended_lines: Lista de líneas extendidas en formato [[[x1,y1,x2,y2]]]
        padding: Espacio adicional para incluir alrededor de la columna
        
    Returns:
        Lista de imágenes de columnas corregidas
    """
    # Ordenar líneas de izquierda a derecha
    lines_sorted = sorted([line[0] for line in extended_lines], key=lambda x: (x[0] + x[2])/2)
    
    columns = []
    
    # Procesar cada par de líneas consecutivas
    for i in range(len(lines_sorted) - 1):
        line1 = lines_sorted[i]
        line2 = lines_sorted[i + 1]
        
        # Aplicar padding ajustando las coordenadas
        line1_padded = [
            line1[0] - padding, line1[1],
            line1[2] - padding, line1[3]
        ]
        line2_padded = [
            line2[0] + padding, line2[1],
            line2[2] + padding, line2[3]
        ]
        
        # Corregir perspectiva
        column = correct_column_perspective(image, line1_padded, line2_padded)
        columns.append(column)
    
    return columns

lines = detect_columns(page)

extended_lines = extend_lines_preserving_angle(lines, page)

extended_lines = filter_close_lines_simple(extended_lines)

columns = extract_columns_with_perspective(page, extended_lines, padding=10)

for i, column in enumerate(columns):
        cv2.imwrite(f"columna_corregida_{i+1}.png", column)


def extract_rows(imagen_path, umbral_negro=35, espacio_minimo=25, umbral_vacio=10):
    # 1. Cargar y preprocesar imagen
    img = cv2.imread(imagen_path, cv2.IMREAD_GRAYSCALE)
    _, img_bin = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    altura, ancho = img_bin.shape

    #2. Detectar filas "vacías" (0-5 píxeles negros)
    filas_vacias = [y for y in range(altura) if np.sum(img_bin[y, :]) <= 255 * umbral_vacio]
    
    # 3. Calcular proyección horizontal para el método original
    proyeccion = np.sum(img_bin, axis=1) / 255
    
    # 4. Detectar regiones de texto (método original)
    lineas = []
    en_texto = False
    inicio_texto = 0
    
    for y, count in enumerate(proyeccion):
        if count > umbral_negro and not en_texto:
            en_texto = True
            inicio_texto = y
        elif count <= umbral_negro and en_texto:
            en_texto = False
            fin_texto = y
            if fin_texto - inicio_texto >= 5:
                lineas.append((inicio_texto, fin_texto))
    
    # 5. Combinar ambos métodos
    todos_separadores = filas_vacias.copy()
    
    # Añadir líneas divisorias del método original que no estén cerca de filas vacías
    for i in range(len(lineas) - 1):
        y_linea = lineas[i][1] + (lineas[i+1][0] - lineas[i][1]) // 2
        
        # Verificar si está suficientemente lejos de las filas vacías existentes
        if all(abs(y_linea - y_vacio) >= espacio_minimo/2 for y_vacio in filas_vacias):
            todos_separadores.append(y_linea)
    
    # 6. Ordenar y filtrar separadores manteniendo 20px mínimo
    todos_separadores = sorted(todos_separadores)
    separadores_finales = []
    
    if todos_separadores:
        separadores_finales.append(todos_separadores[0])
        for y in todos_separadores[1:]:
            if y - separadores_finales[-1] >= espacio_minimo:
                separadores_finales.append(y)
    
    # 7. Asegurarnos de cubrir toda la imagen
    if not separadores_finales or separadores_finales[0] > espacio_minimo:
        separadores_finales.insert(0, 0)
    if separadores_finales[-1] < altura - espacio_minimo:
        separadores_finales.append(altura)
    
    # 8. Dibujar líneas y extraer renglones
    img_color = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
    renglones = []
    y_anterior = 0
    
    for y in separadores_finales:
        # Dibujar línea verde para filas vacías, azul para otras
        color = (0, 255, 0) if y in filas_vacias else (255, 0, 0)
        cv2.line(img_color, (0, y), (ancho, y), color, 1)
        
        renglon = img[y_anterior:y, :]
        if renglon.shape[0] > 5:  # Ignorar renglones muy pequeños
            renglones.append(renglon)
        y_anterior = y
    
    # Añadir último renglón si queda contenido
    if y_anterior < altura - 5:
        renglones.append(img[y_anterior:, :])
    
    return img_color, renglones

# Uso
imagen_path = 'columna_corregida_3.png'
img_con_lineas, renglones = extract_rows(imagen_path)

# Visualización 
plt.figure(figsize=(16, 10), dpi=150)
plt.imshow(img_con_lineas, cmap='gray', vmin=0, vmax=255)
plt.axis('off')
plt.tight_layout()
plt.show()

# Guardar cada renglón
for i, renglon in enumerate(renglones):
    cv2.imwrite(f'renglon_{i}.png', renglon)


#Implementacion de preprocesamiento completo, input Carpeta de Fotos -> Output Paginas/Columnas/Celdas

#Carpeta de fotos
photo_folder = r"D:\Example Ingreso AA\Libro AA"
#Carpeta "procesados" donde se guardan las paginas
processed_folder = r"C:\Users\admin\Documents\Archivologia\procesados"
#Carpeta "columnas" donde se guardan las columnas de cada pagina procesada
processed_columns = r"C:\Users\admin\Documents\Archivologia\procesados\columnas"


# EXTRACCION Y GUARDADO DE PAGINA, COLUMNA Y RENGLON
def process_photo_folder(carpeta_input, output_dir="procesados"):
    """Procesa todos los archivos de imagen en una carpeta"""
    import glob
    
    # Crear directorio de salida
    os.makedirs(output_dir, exist_ok=True)
    
    # Obtener lista de imágenes (jpg, jpeg, png)
    formatos = ('*.jpg', '*.jpeg', '*.png', '*.JPG', '*.JPEG', '*.PNG')
    archivos_imagen = []
    for fmt in formatos:
        archivos_imagen.extend(glob.glob(os.path.join(carpeta_input, fmt)))
    
    if not archivos_imagen:
        print(f"No se encontraron imágenes en: {carpeta_input}")
        return
    
    print(f"Procesando {len(archivos_imagen)} imágenes encontradas...")
    
    for i, img_path in enumerate(archivos_imagen, 1):
        print(f"\n[{i}/{len(archivos_imagen)}] Procesando: {os.path.basename(img_path)}")
        process_document(img_path, output_dir)
    
    print("\nProcesamiento completo!")

def process_document(image_path, output_dir="procesados"):
    try:
        # Verificar que el archivo exista
        if not os.path.isfile(image_path):
            print(f"Archivo no encontrado: {image_path}")
            return None
            
        print(f"Cargando imagen: {image_path}")
        img = cv2.imread(image_path)
        if img is None:
            raise ValueError("No se pudo cargar la imagen")
        
        # Resto del pipeline...
        processed = preprocess_page(image_path, max_width=1800)
        image, rectangle = preprocess_page_rectangle(processed)
        page = crop_rectangular_region(processed, rectangle, margin=-10)
        
        nombre_base = os.path.splitext(os.path.basename(image_path))[0]
        output_path = os.path.join(output_dir, f"{nombre_base}_procesado_hq.png")
        
        cv2.imwrite(output_path, page, [cv2.IMWRITE_PNG_COMPRESSION, 0])
        print(f"Guardado en: {output_path}")
        return output_path
        
    except Exception as e:
        print(f"ERROR procesando {image_path}: {str(e)}")
        return None

def process_columns(carpeta_procesados="procesados"):
    """Procesa todas las imágenes en la carpeta 'procesados' para extraer columnas"""
    
    # Crear carpeta principal para columnas si no existe
    os.makedirs("columnas", exist_ok=True)
    
    # Obtener lista de imágenes procesadas
    imagenes_procesadas = glob(os.path.join(carpeta_procesados, "*_procesado_hq.png"))
    
    if not imagenes_procesadas:
        print(f"No se encontraron imágenes procesadas en: {carpeta_procesados}")
        return
    
    print(f"\nIniciando extracción de columnas para {len(imagenes_procesadas)} imágenes...")
    
    for img_path in imagenes_procesadas:
        try:
            print(f"\nProcesando: {os.path.basename(img_path)}")
            
            # Cargar imagen
            page = cv2.imread(img_path)
            if page is None:
                raise ValueError("No se pudo cargar la imagen")
            
            # Procesamiento de columnas
            lines = detect_columns(page)
            extended_lines = extend_lines_preserving_angle(lines, page)
            extended_lines = filter_close_lines_simple(extended_lines)
            columns = extract_columns_with_perspective(page, extended_lines, padding=10)
            
            # Crear subcarpeta para esta imagen
            nombre_base = os.path.splitext(os.path.basename(img_path))[0].replace("_procesado_hq", "")
            output_dir = os.path.join("columnas", nombre_base)
            os.makedirs(output_dir, exist_ok=True)
            
            # Guardar columnas
            for i, column in enumerate(columns, 1):
                output_path = os.path.join(output_dir, f"columna_{i}.png")
                cv2.imwrite(output_path, column, [cv2.IMWRITE_PNG_COMPRESSION, 0])
                print(f"Columna {i} guardada en: {output_path}")
                
        except Exception as e:
            print(f"ERROR procesando {img_path}: {str(e)}")
    
    print("\nProceso de extracción de columnas completado!")

def process_cells(carpeta_columnas="columnas"):
    """Procesa todas las columnas para extraer renglones y guardarlos organizadamente"""
    
    # Crear carpeta principal para renglones si no existe
    os.makedirs("renglones", exist_ok=True)
    
    # Encontrar todas las subcarpetas de columnas
    subcarpetas = [d for d in glob(os.path.join(carpeta_columnas, "*")) if os.path.isdir(d)]
    
    if not subcarpetas:
        print(f"No se encontraron columnas procesadas en: {carpeta_columnas}")
        return
    
    print(f"\nIniciando extracción de renglones para {len(subcarpetas)} documentos...")
    
    for subcarpeta in subcarpetas:
        try:
            nombre_doc = os.path.basename(subcarpeta)
            print(f"\nProcesando documento: {nombre_doc}")
            
            # Crear estructura de carpetas para los resultados
            output_dir = os.path.join("renglones", nombre_doc)
            os.makedirs(output_dir, exist_ok=True)
            
            # Procesar cada columna en esta subcarpeta
            columnas = glob(os.path.join(subcarpeta, "columna_*.png"))
            
            for col_path in columnas:
                nombre_col = os.path.splitext(os.path.basename(col_path))[0]
                col_dir = os.path.join(output_dir, nombre_col)
                os.makedirs(col_dir, exist_ok=True)
                
                print(f"  Procesando {nombre_col}...")
                
                # Extraer renglones (usando tu función existente)
                img_con_lineas, renglones = extract_rows(col_path)
                
                # Guardar resultados
                cv2.imwrite(os.path.join(col_dir, "visualizacion_lineas.png"), img_con_lineas)
                
                for i, renglon in enumerate(renglones):
                    output_path = os.path.join(col_dir, f"renglon_{i+1:03d}.png")
                    cv2.imwrite(output_path, renglon, [cv2.IMWRITE_PNG_COMPRESSION, 0])
                
                print(f"  {len(renglones)} renglones extraídos en: {col_dir}")
                
        except Exception as e:
            print(f"ERROR procesando {subcarpeta}: {str(e)}")
    
    print("\nProceso de extracción de renglones completado!")

# Ejecutar el procesamiento
if __name__ == "__main__":
    process_cells()

process_photo_folder(photo_folder)

process_columns(processed_folder)

process_cells(processed_columns)